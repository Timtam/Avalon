<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, September 04, 2008, 8:36 PM -->
<!-- MuClient version 4.18 -->

<!-- Plugin "QueueControl" generated by Plugin Wizard -->

<muclient>
<plugin
   name="QueueControl"
   author="Malix@8bit"
   id="95050dd3b17cfb76ef13b017"
   language="Lua"
   purpose="Gives you more control over the speedwalk queue."
   date_written="2008-09-04 20:34:53"
   requires="3.52"
   version="1.0"
   >
<description trim="y">
<![CDATA[
This plugin gives you added control over the speedwalk queue. It allows you to pause, resume, and display the number of commands on the queue.

**** Commands ****

queuedelay <#>
  This command sets the speedwalk delay for the current world to <#> milliseconds, so you don't have to go into the configuration window.

queuecount
  This command displays the number of commands currently on the queue, and if the queue is paused, how many are stored.

queuepause
  This command pauses the queue, storing the commands currently on it, and discarding it.

queueresume
  This command resumes the queue, it requeues the commands that were stored when the queue paused.

queuetoggle
  This command toggles the queue between paused and unpaused.

There are also alias menu(Ctrl-Click) commands for pausing and resuming.

The following are special commands to be run from triggers that detect when the game pauses to save the database for example.

queuegamepause
  This command remembers whether the queue was already paused, and if not, pauses it.

queuegameresume
  This command resumes the queue if it was paused by the game pause.

Just add a trigger, set it to match on whatever message is shown when the game pauses. In the send box type queuegamepause, and in the send to combobox select execute. Repeat for queuegameresume with the message shown when the game resumes.

]]>
</description>

</plugin>


<!--  Aliases  -->

<aliases>
  <alias
   name="Resume_Queue"
   script="OnQueueResume"
   match="queueresume"
   enabled="y"
   group="QueueControl"
   sequence="100"
  >
  </alias>
  <alias
   name="Toggle_Queue_Paused"
   script="OnQueueToggle"
   match="queuetoggle"
   enabled="y"
   group="QueueControl"
   sequence="100"
  >
  </alias>
  <alias
   script="OnGameResume"
   match="queuegameresume"
   enabled="y"
   group="QueueControl"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="OnGamePause"
   match="queuegamepause"
   enabled="y"
   group="QueueControl"
   omit_from_command_history="y"
   omit_from_log="y"
   omit_from_output="y"
   sequence="100"
  >
  </alias>
  <alias
   script="OnQueueCount"
   match="queuecount"
   enabled="y"
   group="QueueControl"
   sequence="100"
  >
  </alias>
  <alias
   script="OnQueueDelay"
   match="^queuedelay(?: (.+?))?$"
   enabled="y"
   group="QueueControl"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="Pause_Queue"
   script="OnQueuePause"
   match="queuepause"
   enabled="y"
   group="QueueControl"
   menu="y"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Script  -->


<script>
<![CDATA[
savQueue = {} -- The array to store the queue in.
bQueuePaused = false -- Is the queue suspended?
bGamePause = false -- Was the queue suspended before a game pause.

function PauseQueue ()
	if bQueuePaused then
		world.Note("The queue is already paused.")
		return
	end
	if world.GetInfo(222) == 0 then
		world.Note("There are no commands in the queue.")
		return
	end
	world.Tell("Storing Queue...")
	savQueue = {};
	for k, v in pairs(world.GetQueue()) do
		savQueue[k] = v
	end
	world.Note("Discarding Queue")
	world.DiscardQueue()
	world.SetAliasOption("Pause_Queue","menu",0)
	world.SetAliasOption("Resume_Queue","menu",1)
	bQueuePaused = true
end

function ResumeQueue()
	if not bQueuePaused then
		world.Note("The queue isn't paused.")
		return
	end
	world.Note("Restoring Queue")
	if next(savQueue) ~= nil then
		for k, v in pairs(savQueue) do
			world.Queue(savQueue[k], true)
		end
	end
	savQueue = {}; -- Discard stored queue.
	world.SetAliasOption("Pause_Queue","menu",1)
	world.SetAliasOption("Resume_Queue","menu",0)
	bQueuePaused = false
end


function OnQueuePause (thename, theoutput, wildcardsVB) PauseQueue() end

function OnQueueResume (thename, theoutput, wildcardsVB) ResumeQueue() end

function OnQueueToggle (thename, theoutput, wildcardsVB)
	if bQueuePaused then
		ResumeQueue()
	else
		PauseQueue()
	end
end

--[==[/* function NumOnQueue() {
	return world.GetInfo(222);
} */ ]==]

function OnQueueCount(thename, theoutput, wildcardsVB)
	world.Note("# of commands on queue=" .. world.GetInfo(222))
	if bQueuePaused and savQueue ~= nil and (next(savQueue) ~= nil) then
		world.Note(table.maxn(savQueue) .. " commands in storage.")
	end
end

function OnGamePause(thename, theoutput, wildcardsVB)
	world.Note("Game pause detected, storing current queue status and pausing queue.");
	bGamePause = bQueuePaused  -- Store whether the queue was already paused or not.
	if not bQueuePaused and (world.GetInfo(222) > 0) then -- If there's commands on the queue, pause the queue.
		PauseQueue()
	end
end

function OnGameResume(thename, theoutput, wildcardsVB)
	world.Note("Game resume detected restoring previous status.")
	if not bGamePause and bQueuePaused then -- If the queue wasn't suspended before the game paused resume it.
		ResumeQueue()
	end
end

function OnQueueDelay(thename, theoutput, wildcards)
	-- wildcards = VBArray(wildcardsVB).toArray();
	if wildcards[1] and string.len(wildcards[1]) > 0 then
		delay = tonumber(wildcards[1])
		if delay >= 0 and delay <= 30000 then
			world.SetSpeedWalkDelay (delay)
			world.Note("Speedwalk delay set to " .. delay .. " milliseconds.")
		else
			world.Note("Invalid value for speedwalk delay, valid values are between 0 and 30000 ms.")
		end
	else
		world.Note("Current speedwalk queue delay is " .. world.GetSpeedWalkDelay() .. " milliseconds.")
	end
end

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="QueueControl:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
