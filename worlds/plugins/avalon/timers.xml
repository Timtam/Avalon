<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Montag, Dezember 31, 2018, 5:48  -->
<!-- MuClient version 5.05 -->

<!-- Plugin "timers" generated by Plugin Wizard -->

<muclient>
<plugin
   name="timers"
   author="Magician"
   id="502d3d0a4888111e44823e5d"
   language="Lua"
   purpose="Diverse Timer-Funktionalitaeten"
   save_state="n"
   date_written="2018-12-31 05:48:28"
   requires="4.70"
   version="1.0"
   >

</plugin>

<!--  Aliases  -->

<aliases>
  <alias
   regexp="y"
   match="^timer$"
   enabled="y"
   sequence="99"
   send_to="12"
  >
  <send>timers_print()</send>
  </alias>
  <alias
   regexp="y"
   match="^timer neu *([a-zA-Z0-9]*) *([0-9]*) *([0-9]*)$"
   enabled="y"
   sequence="100"
   send_to="12"
  >
  <send>timers_add("%1", "%3", "%2")</send>
  </alias>
  <alias
   regexp="y"
   match="^timer beende *([a-zA-Z0-9]*)$"
   enabled="y"
   sequence="100"
   send_to="12"
  >
  <send>timers_end("%1")</send>
  </alias>
</aliases>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->

<script>
<![CDATA[
PPI = require("ppi")
Tablex = require("pl.tablex")
Timers = require("timers")
Types = require("pl.types")

timer_processor = Timers.TimerProcessor()
timers = {}

function timers_print()
  timer_processor:Print()
end

function timers_add(name, tick, duration, end_sound)

  if Types.is_empty(name) then
    world.Note("timer neu <name> <laenge> <warnzeit>")
    world.Note("Legt einen neuen Timer an. Dabei werden die folgenden Argumente beruecksichtigt:")
    world.Note("\tname: Der Name des Timers in der Liste")
    world.Note("\tlaenge: Laenge des Timers (er wird danach automatisch beendet)")
    world.Note("\t\twird 0 angegeben, laeuft er solange, bis er manuell beendet wird")
    world.Note("\t\toder der Client neu gestartet wird")
    world.Note("\twarnzeit: immer nach der hier angegebenen Zeit wird ein Hinweis ausgegeben")
    world.Note("\t\twird 0 angegeben, wird keine Warnung ausgegeben")
    world.Note("Saemtliche Zeit muss in Sekunden angegeben werden.")
    return
  end

  id = timer_processor:AddTimer(name, tick, duration, end_sound, true)
  timers[name:lower()] = id
  world.Note("Der Timer wurde erstellt.")
end

function timers_end(name)
  if Types.is_empty(name) then
    world.Note("timer beende <name>")
    world.Note("Beendet einen laufenden Timer manuell. Folgende Argumente werden benoetigt:")
    world.Note("\tname: Name des Timers")
    return
  end

  t = timers[name:lower()]

  if Types.is_empty(t) then
    world.Note("Ein Timer mit diesem Namen wurde nicht gefunden.")
    return
  end

  res = timer_processor:EndTimer(t)

  if res == Timers.NOT_FOUND then
    world.Note("Ein Timer mit diesem Namen wurde nicht gefunden.")
  elseif res == Timers.MULTIPLE_RESULTS then
    world.Note("Es gibt mehrere Timer, auf welche dieser Name zutrifft. Dieser Fehler duerfte nie auftreten.")
  end

  timers[name:lower()] = nil
end

function OnPluginInstall()
  PPI.Expose('AddTimer', function(name, tick, duration, end_sound)
    id = timer_processor:AddTimer(name, tick, duration, end_sound)

    if id ~= Timers.ALREADY_EXISTS then
      timers[name:lower()] = id
    end

    return id
  end)

  PPI.Expose('EndTimer', function(id)
    res = timer_processor:EndTimer(id)

    if res == nil then
      name = Tablex.find(timers, id)

      if name ~= nil then
        timers[name] = nil
      end
    end

    return res
  end)

  PPI.Expose('SetTick', function(id, tick)
    return timer_processor:SetTick(id, tick)
  end)

end

function OnPluginTick()
  timer_processor:Tick()
end
]]>
</script>

</muclient>
