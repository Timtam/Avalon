<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Donnerstag, März 20, 2014, 1:35  -->
<!-- MuClient version 4.91 -->

<!-- Plugin "Update" generated by Plugin Wizard -->

<muclient>
<plugin
   name="updater"
   author="Magician"
   id="335ef2e8fe775511593881e0"
   language="Lua"
   purpose="Update-Informationen zum Avalon-Soundpack"
   save_state="n"
   date_written="2016-11-16 17:34:01"
   requires="4.55"
   version="1.0"
   >

</plugin>

<aliases>
  <alias
   match="update"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>updateCheckForce()</send>
  </alias>
  <alias
   match="update hard"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>updateReset()</send>
  </alias>
  <alias
   match="update vcs"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>updateVCS()</send>
  </alias>
  <alias
   match="update info"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  <send>updateInfo()</send>
  </alias>
</aliases>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->


<script>
<![CDATA[
async = require("async")
avalon = nil
avalonId = world.GetPluginVariable("", "avalon")
checkPeriod = 900 -- 15 minutes
commitFetchUrl="https://api.github.com/repos/Timtam/Avalon/commits?sha=master"
downloadThread = nil
informed = false
json=require("json")
loggedIn = false
messageWidth = 80
path = require("pl.path")
ppi=require("ppi")
stringx = require("pl.stringx")
tabLength=4
translationTable={}
-- this is unbelievably ugly, but it works... as long as the encodings support doesn't get better
translationTable["Ã¤"] = "ae"
translationTable["Ã¼"] = "ue"
translationTable["Ã¶"] = "oe"
translationTable["Ã„"] = "Ae"
translationTable["Ã–"] = "Oe"
translationTable["Ãœ"] = "Ue"
translationTable["ÃŸ"] = "ss"
-- uglyness ends here
vcsFolders={".git",".svn"}
verbose = false

world.DoAfterSpecial(0.5, "PluginInstall()", sendto.script)
avalon = ppi.Load(avalonId)

function updateCheck()
  local vcs
  if avalon.GetConfig("update","vcspassthrough") == 0 then
    for vcs in pairs(vcsFolders) do
      if path.isdir(world.GetInfo(66)..vcsFolders[vcs]) == true then
        if verbose == true then
          world.Note("Soundpack laeuft via VCS, Updates werden nicht geprueft.")
          world.Note("Dieses Verhalten kann mittels update vcs geaendert werden.")
          world.Note("Vorsicht: Dies kann zu fehlerhaft gemeldeten Aktualisierungen fuehren.")
          verbose = false
        end
        return
      end
    end
  end
  if informed == true then
    -- no verbose check here, since verbose is always toggled by user command
    -- and a second run can't be invoked by users yet
    return -- updater will check at next start only, since we already informed one time
  end
  if loggedIn == true then
    downloadThread = async.request(commitFetchUrl, "HTTPS")
    world.DoAfterSpecial(1, "updateCheckFinished()",sendto.script)
  else
    if verbose == true then
      world.Note("Damit eine Pruefung durchgefuehrt werden kann, muss ein")
      world.Note("Charakter in Avalon eingeloggt sein.")
      verbose = false
    end
  end
end

function updateCheckFinished()
  local commits, current, hours, minutes, seconds
  if downloadThread:alive()==true then
    world.DoAfterSpecial(1, "updateCheckFinished()", sendto.script)
    return
  end
  local retval, page, status, headers, full_status = downloadThread:join()
  if page ~= nil then
    commits = json.decode(page)
    current = avalon.GetConfig("update", "hash")
    if current == 0 or avalon.GetConfig("update", "updated") == 1 then
      -- no hash set yet, for example when downloading as zip file
      -- also the updater may have run recently, same procedure
      -- or the user forced to update the current hash value
      avalon.SetConfig("update","hash",commits[1]["sha"])
      avalon.SetConfig("update", "updated", 0)
      if verbose == true then
        world.Note("Die derzeitige Version wurde auf folgenden Hash festgesetzt:")
        world.Note(commits[1]["sha"])
        verbose = false
      end
    else
      -- valid hash already set and updater not active since the last check
      if current ~= commits[1]["sha"] then
        printUpdateMessage(commits, current)
        informed = true
        verbose = false
        avalon.PSND("misc/update.ogg")
      else
        if verbose == true then
          world.Note("Das Soundpack ist aktuell.")
          verbose = false
        end
      end
    end
  else
    if verbose == true then
      world.Note("Es trat ein Fehler beim Download der Update-Informationen auf.")
      world.Note("Eventuell ist der Server derzeit nicht erreichbar oder")
      world.Note("der Zugriff wird durch eine Firewall oder einen")
      world.Note("Proxy-Server eingeschraenkt.")
      verbose = false
    end
  end
  hours = math.floor(checkPeriod/3600)
  minutes = math.floor((checkPeriod - hours*3600)/60)
  seconds = checkPeriod - hours * 3600 - minutes*60
  world.AddTimer("updateCheckTimer", hours, minutes, seconds, "", timer_flag.Enabled+timer_flag.OneShot+timer_flag.Temporary, "updateCheck") 
end

function PluginInstall()
  avalon.HookCallback("LOGIN", function()
    loggedIn = true
    updateCheck()
  end)
  avalon.HookCallback("LOGOUT", function()
    loggedIn = false
    world.EnableTimer("updateCheckTimer", 0)
    world.DeleteTimer("updateCheckTimer")
  end)
end

function printUpdateMessage(commits, current)
  -- will print an update message, displaying new stuff for the user
  local char
  local currentIndex = 1
  local i
  local message
  while currentIndex <= #commits and commits[currentIndex]["sha"] ~= current do
    -- we'll filter all merge commits right here
    -- and also all commits with no message
    if string.find(commits[currentIndex]["commit"]["message"], "Merge branch") == 1 or stringx.strip(commits[currentIndex]["commit"]["message"])=="" then
      table.remove(commits, currentIndex)
    else
      -- and we will replace all misformatted chars
      for char in pairs(translationTable) do
        commits[currentIndex]["commit"]["message"]=string.gsub(commits[currentIndex]["commit"]["message"], char, translationTable[char])
      end
      currentIndex = currentIndex + 1
    end
  end
  i = currentIndex - 1

  -- formatting the message
  message = "Es ist ein Update fuer das Soundpack verfuegbar!\n"
  if i == 0 then
    -- the newest commit is ONLY a merge commit or a commit without a message
    message = message.."Es sind allerdings keine Informationen ueber den Inhalt bekannt.\n"
  else
    message = message.."Die neuesten Aenderungen auf einen Blick:"
    world.Note(message)
    message = ""

    while i >= 1 do
      message = message.. tostring(currentIndex - i)..".\n"
      message = message..formatCommitMessage(commits[i]["commit"]["message"]).."\n"
      i = i - 1
    end
    if currentIndex > #commits then
      message = message.."Weitere Aenderungen koennten vorgenommen worden sein.\n"
      message = message.."Das Soundpack prueft immer nur die neuesten Aktualisierungen.\n"
    end
    Avalon.NoteColour(message, 0, 204, 102) -- light green
    message = ""
  end
  message = message.."Es wird empfohlen, das Soundpack zu aktualisieren. Dafuer muss der MUSHclient geschlossen\n"
  message = message.."und die update.exe im Soundpack ausgefuehrt werden.\n"
  message = message .. "Weitere Informationen mit update info."
  world.Note(message)
end

function updateCheckForce()
  if downloadThread ~=nil and downloadThread:alive() == true then
    world.Note("Es ist bereits eine Pruefung in Gange.")
    return
  end
  informed = false
  verbose = true
  world.Note("Es wird nach Aktualisierungen gesucht...")
  updateCheck()
end

function updateReset()
  if downloadThread ~= nil and downloadThread:alive() == true then
    world.Note("Es laeuft derzeit eine Pruefung.")
    return
  end
  verbose = true
  informed = false
  avalon.SetConfig("update", "updated", 1)
  world.Note("Die aktuelle Soundpack-Version wird auf die derzeit neueste Version festgelegt.")
  updateCheck()
end

function updateVCS()
  if downloadThread ~= nil and downloadThread:alive() == true then
    world.Note("Es laeuft gerade eine Pruefung.")
    return
  end
  if avalon.GetConfig("update", "vcspassthrough") == 0 then
    world.Note("Updates werden nun trotz Verwendung von externen VCS geprueft.")
    avalon.SetConfig("update", "vcspassthrough", 1)
    updateCheck()
  else
    world.Note("Die Update-Pruefung wird wieder unterbunden.")
    avalon.SetConfig("update", "vcspassthrough", 0)
    world.EnableTimer("updateCheckTimer", 0)
    world.DeleteTimer("updateCheckTimer")
  end
end

function formatCommitMessage(msg)
  -- copied and adapted from original source in message_window plugin
  -- will cut the messages into size and format them properly
  local words
  local wordindex
  local message
  local messageindex
  local tlinesindex = 1
  local tlines = {}
  for messageindex, message in pairs(utils.split(msg, "\n")) do
    wordindex = 1
    words = {}
    for line in string.gmatch(message, "%S+") do
      words[#words + 1] = line
    end
    while wordindex <= #words do
      line = words[wordindex]
      tlines[tlinesindex] = tlines[tlinesindex] or stringx.expandtabs("\t", tabLength)
      if string.len(line)+string.len(tlines[tlinesindex])>messageWidth then
        if tlines[tlinesindex]==stringx.expandtabs("\t", tabLength) then
          tlines[tlinesindex]=tlines[tlinesindex]..line
          wordindex = wordindex + 1
        end
        tlinesindex=tlinesindex+1
      else
        tlines[tlinesindex]=tlines[tlinesindex]..line.." "
        wordindex = wordindex + 1
      end
    end
    tlinesindex = tlinesindex + 1
  end

  return table.concat(tlines, "\n")
end

function updateInfo()
  message = ""
  if downloadThread:alive()==true then
    message = message .. "Es wird gerade auf Aktualisierungen geprueft.\n"
  else
    message = message .. "Es wird gerade nicht auf Aktualisierungen geprueft.\n"
  end
  if informed == true then
    message = message .. "Es wurde bereits eine Information in dieser Sitzung angezeigt.\n"
  else
    message = message .. "Es wird eine Information pro Sitzung angezeigt.\n"
  end
  message = message.."Um spaeter erneut auf Aktualisierungen zu pruefen, muss das Soundpack\n"
  message = message.."neu gestartet werden, oder der Befehl\n"
  message = message.."update ausgefuehrt werden.\n"
  message = message.."Sollte diese Meldung versehendlich angezeigt werden,\n"
  message = message.."kann die aktuelle Version mittels\n"
  message = message.."update hard auf die derzeit neueste Version festgelegt werden."
  world.Note(message)
end
]]>
</script>


</muclient>
