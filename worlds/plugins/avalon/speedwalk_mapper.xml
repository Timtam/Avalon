<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Dienstag, September 09, 2014, 10:34  -->
<!-- MuClient version 4.92 -->

<!-- Plugin "avalon_speedwalk_mapper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="speedwalk_mapper"
   author="Magician"
   id="deb5a26f21c54c6a913af6d9"
   language="Lua"
   purpose="Zeichnet Avalon Speedwalks auf und formatiert sie in das Soundpack-gerechte Format"
   save_state="n"
   date_written="2014-09-09 10:32:54"
   requires="4.70"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   regexp="y"
   match="^spm start$"
   enabled="y"
   sequence="100"
   send_to="12"
  >
  <send>spm_start()</send>
  </alias>
  <alias
   regexp="y"
   match="^spm z$"
   enabled="y"
   sequence="100"
   send_to="12"
  >
  <send>spm_removelast()</send>
  </alias>
  <alias
   regexp="y"
   match="^spm (stopp|stop)$"
   enabled="y"
   sequence="100"
   send_to="12"
  >
  <send>spm_stop()</send>
  </alias>
</aliases>

<!--  Script  -->

<script>
<![CDATA[

Active = false
CmdStack = {}
Const = require("speedwalking.constants")
Dunkel = 0
EndID = ""
EndDescription = ""
EndDomain = ""
EndName = ""
RoomID = nil
StartID = ""
StartDomain = ""
StartDescription = ""
StartName = ""
Stations = require("avalon.stations")
Templates = require("pl.template")
Utils = require("speedwalking.utils")
Warned = false

PPI = require("ppi")

Avalon = PPI.Load(world.GetPluginVariable("", "avalon"))

Shorters = {}
Shorters.osten = "o"
Shorters.westen = "w"
Shorters.suedwesten = "sw"
Shorters.sueden = "s"
Shorters.norden = "n"
Shorters.suedosten = "so"
Shorters.nordosten = "no"
Shorters.nordwesten = "nw"
Shorters.e = "o"
Shorters.se = "so"
Shorters.ne = "no"

Template = [[# _ = nil
stations:add(
             "$(StartDomain)",
             "$(StartName)",
             "$(StartID)",
             "$(StartDescription)"
            )

stations:add(
             "$(EndDomain)",
             "$(EndName)",
             "$(EndID)",
             "$(EndDescription)"
            )

speedwalklist['$(StartDomain).$(StartName)_$(EndDomain).$(EndName)'] = "$(Speedwalk)"
speedwalklist['$(EndDomain).$(EndName)_$(StartDomain).$(StartName)'] = "$(ReversedSpeedwalk)"
]]

world.DoAfterSpecial(0.5, "PluginInstall()", sendto.script)

function PluginInstall()
  Avalon.HookCallback("ROOMID", OnAvalonRoomID)
  Avalon.HookCallback("DUNKEL", OnAvalonDunkel)
end

function OnAvalonRoomID(id)
  RoomID = id
end

function OnAvalonDunkel(dunkel)
  Dunkel = dunkel
end

function OnPluginSend(text)
  if Active then
    text = _spm_processcommand(text)
  end
  return true
end

function spm_start()
  if Dunkel == 1 then
    world.Note("Die Aufzeichnung kann nur im Hellen erfolgen.")
    return
  end
  id = RoomID
  s = Stations:find(id)
  if s:len() > 0 then
    StartDomain = s[1].domain
    StartDescription = s[1].description
    StartName = s[1].name
  else
    StartDomain = ""
    StartDescription = ""
    StartName = ""
  end
  StartID = id
  Active = true
  world.Note("Der Avalon-Speedwalk-Mapper zeichnet nun einen Speedwalk auf.")
  world.Note("Bitte bis zum Ende der Aufnahme nur Kommandos verwenden, die im eigentlichen Speedwalk auch auftauchen sollen.")
  world.Note("Es dürfen dabei keine selbst definierten Aliase verwendet werden.")
  world.Note("Zum Beenden das Kommando \"spm stop\" benutzen.")
end

function spm_stop()
  if not Active then
    return
  end
  if #CmdStack > 0 and RoomID ~= StartID then
    id = RoomID
    if Dunkel == 1 then
      world.Note("Beim Abschluss des Speedwalks muss es ebenfalls hell sein.")
      world.Note("Dafür wird eine Lichtquelle benoetigt, bevor der Speedwalk beendet werden kann.")
      return
    end
    EndID = id
    s = Stations:find(id)
    if s:len() > 0 then
      EndDomain = s[1].domain
      EndDescription = s[1].description
      EndName = s[1].name
    else
      EndDomain = ""
      EndDescription = ""
      EndName = ""
    end
    world.Note("Die Aufzeichnung ist abgeschlossen.")
    world.Note("Anschließend werden noch folgende Informationen benoetigt:")
    StartDomain = utils.inputbox("Bitte den Namen der Startdomäne des Speedwalks eingeben:", "Avalon-Speedwalk-Mapper", StartDomain)
    if StartDomain == nil then
      world.Note("Der Name der Startdomaene darf nicht leer sein. Beispiel: minias")
      return
    end
    StartName = utils.inputbox("Bitte den Namen des Startortes des Speedwalks eingeben:", "Avalon-Speedwalk-Mapper", StartName)
    if StartName == nil then
      world.Note("Der Name der Startposition darf nicht leer sein. Beispiel: eingang")
      return
    end
    StartDescription = utils.inputbox("Bitte eine nützliche Beschreibung für den Startort eingeben:", "Avalon-Speedwalk-Mapper", StartDescription)
    if StartDescription == nil then
      world.Note("Die Beschreibung für den Startort darf nicht leer sein.")
      return
    end
    EndDomain = utils.inputbox("Bitte den Namen der Enddomäne des Speedwalks eingeben:", "Avalon-Speedwalk-Mapper", EndDomain)
    if EndDomain == nil then
      world.Note("Der Name der Enddomäne darf nicht leer sein. Beispiel: alotria")
      return
    end
    EndName = utils.inputbox("Bitte den Namen des Zielortes des Speedwalks eingeben:", "Avalon-Speedwalk-Mapper", EndName)
    if EndName == nil then
      world.Note("Der Name des Zielortes darf nicht leer sein. Beispiel: haendler")
      return
    end
    EndDescription = utils.inputbox("Bitte eine Beschreibung für den Zielort des Speedwalks eingeben:", "Avalon-Speedwalk-Mapper", EndDescription)
    if EndDescription == nil then
      world.Note("Die Beschreibung des Zielortes darf nicht leer sein.")
      return
    end
    if StartName == EndName then
      world.Note("Die Start- und Endpositionen dürfen nicht identisch sein.")
      return
    end
    local speedwalk = _spm_getspeedwalk()
    local reversespeedwalk = _spm_getspeedwalkreverse()
    output = Templates.substitute(Template, {
      StartDescription = StartDescription,
      StartDomain = StartDomain,
      StartID = StartID,
      StartName = StartName,
      EndDescription = EndDescription,
      EndDomain = EndDomain,
      EndID = EndID,
      EndName = EndName,
      Speedwalk = speedwalk,
      ReversedSpeedwalk = reversespeedwalk
    })
    output = world.Replace(output, "\n", "\r\n", true)
    SetClipboard(output)
    world.Note("Die gesammelten Informationen zum Speedwalk befinden sich nun in der Zwischenablage.")
  else
    if StartID == RoomID then
      world.Note("Die Verarbeitung wurde abgebrochen, da die Start- und Endposition identisch sind.")
    else
      world.Note("Für diesen Speedwalk wurden keine Eingaben registriert.")
    end
  end
  CmdStack = {}
  EndDescription = ""
  EndDomain = ""
  EndName = ""
  EndID = ""
  StartDescription = ""
  StartDomain = ""
  StartName = ""
  StartID = ""
  Active = false
  Warned = false
end

function spm_removelast()
  world.Note("Eingabe \""..CmdStack[#CmdStack].."\" gelöscht.")
  CmdStack[#CmdStack] = nil
end

function _spm_getspeedwalk()
  speedwalk = ""
  for index, cmd in pairs(CmdStack) do
    speedwalk = speedwalk..cmd.." "
  end
  return string.sub(speedwalk, 1, -2)
end

function _spm_processcommand(text)
  text = string.lower(text)
  if Shorters[text] then
    text = Shorters[text]
  end
  if string.find(text, " ", 1, true) then
    text = world.Replace(text, " ", "_", true)
  end
  if (not Const.DIRECTIONS[text]) and not (string.find(text, "kletter", 1, true) == 1) and not (string.find(text, "schwimm", 1, true) == 1) and (not Warned) then
    world.Note("Diese Eingabe ist dem Speedwalk-Mapper nicht bekannt. Falls diese Eingabe für die Aufnahme nicht vorgesehen war, kannst Du sie mit \"spm z\" wieder entfernen.")
    Warned = true
  end
  if #CmdStack == 0 then
    CmdStack[#CmdStack+1] = text
    return
  end
  split = utils.split(text, "_")
  lastsplit = utils.split(CmdStack[#CmdStack], "_")
  if Utils.is_inverse(text, CmdStack[#CmdStack]) then
    CmdStack[#CmdStack] = nil
    world.Note("Da die beiden letzten Eingaben sich gegenseitig aufheben, wurden sie automatisch entfernt.")
  else
    CmdStack[#CmdStack+1] = text
  end
end

function _spm_getspeedwalkreverse()
  speedwalk = ""
  for i = #CmdStack, 1, -1 do
    cmd = CmdStack[i]
    split = utils.split(cmd, "_")
    if Const.DIRECTIONS[cmd] then
      cmd = Const.DIRECTIONS[cmd]
    elseif string.find(cmd, "kletter", 1, true) == 1 and Const.DIRECTIONS[split[2]] then
      cmd = split[1].."_"..Const.DIRECTIONS[split[2]]
    elseif string.find(cmd, "schwimm", 1, true) == 1 and Const.DIRECTIONS[split[2]] then
      cmd = split[1].."_"..Const.DIRECTIONS[split[2]]
    else
      cmd = utils.inputbox("Die Eingabe \""..cmd.."\" konnte nicht automatisch umgekehrt werden. Bitte die umgekehrte Variante eingeben, dass dieser bei der Umkehrung verwendet werden kann: ", "Avalon-Speedwalk-Mapper", cmd)
      if cmd == nil then
        world.Note("Es muss eine umgekehrte Eingabe eingegeben werden.")
        return
      end
    end
    speedwalk = speedwalk..cmd.." "
  end
  return string.sub(speedwalk, 1, -2)
end

]]>
</script>

</muclient>
